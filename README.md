# 8주차 과제 체크포인트

## 기본 과제

### 필수

- [x] 반복 유형 선택
  - 일정 생성 또는 수정 시 반복 유형을 선택할 수 있다.
  - 반복 유형은 다음과 같다: 매일, 매주, 매월, 매년
    - 만약, 윤년 29일에 또는 31일에 매월 또는 매년 반복일정을 설정한다면 어떻게 처리할까요? 다른 서비스를 참고해보시고 자유롭게 작성해보세요.
- [x] 반복 간격 설정
  - 각 반복 유형에 대해 간격을 설정할 수 있다.
  - 예: 2일마다, 3주마다, 2개월마다 등
- [x] 반복 일정 표시
  - 캘린더 뷰에서 반복 일정을 시각적으로 구분하여 표시한다.
    - 아이콘을 넣든 태그를 넣든 자유롭게 해보세요!
- [x] 반복 종료
  - 반복 종료 조건을 지정할 수 있다.
  - 옵션: 특정 날짜까지, ~특정 횟수만큼~, 또는 종료 없음 (예제 특성상, 2025-06-30까지)
- [x] 반복 일정 단일 수정
  - 반복일정을 수정하면 단일 일정으로 변경됩니다.
  - 반복일정 아이콘도 사라집니다.
- [x] 반복 일정 단일 삭제
  - 반복일정을 삭제하면 해당 일정만 삭제합니다.

### 선택

- [ ] 예외 날짜 처리:
  - 반복 일정 중 특정 날짜를 제외할 수 있다.
  - 반복 일정 중 특정 날짜의 일정을 수정할 수 있다.
- [ ] 요일 지정 (주간 반복의 경우):
  - 주간 반복 시 특정 요일을 선택할 수 있다.
- [ ] 월간 반복 옵션:
  - 매월 특정 날짜에 반복되도록 설정할 수 있다.
  - 매월 특정 순서의 요일에 반복되도록 설정할 수 있다.
- [ ] 반복 일정 전체 수정 및 삭제
  - 반복 일정의 모든 일정을 수정할 수 있다.
  - 반복 일정의 모든 일정을 삭제할 수 있다.

## 심화 과제

- [x] 이 앱에 적합한 테스트 전략을 만들었나요?

### 각 팀원들의 테스트 전략은?

- 주희
    - 통합 테스트 작성 > 단위 테스트 작성
    - 처음부터 세부 기능에 대한 테스트 시나리오를 떠올리기 어려워서 큰 범위의 통합 테스트 먼저 작성
    - 통합 테스트는 1~4를 연계해서 작성 (ex: 매월 반복되는 일정을 생성하면 주간 뷰 달력에 아이콘과 함께 매달 표시된다.)
    - 1, 2, 4 기능 검증은 단위 테스트로 작성 (ex: '매월 반복' 설정의 이벤트를 입력하면, 한달 간격의 일정 배열을 반환한다.)
    - 그런데 TDD 흐름대로 하려면 단위 테스트 > 통합 테스트 순으로 작성해야 한다는 것을 알았음
  
- 기훈
    1. 요구 사항 파악
    2. server.js에 추가된 반복 일정 관련 API 파악 -> 예상 데이터 구조 파악
    3. server.js 참고하여 handlers.ts와 handlersUtils.ts에 추가된 API 핸들러 함수 작성 (MSW 설정)
    4. 기능이 추가되어야 하는 부분에 분기 처리 & 적절한 부분에 추가 기능 관련 함수 생성 (이름만 만들기)
    5. 이름만 생성해둔 함수에 대해 유닛테스트 작성
    6. 기능에 대한 통합 테스트 작성
    7. 테스트 코드에 맞춰 기능 구현
    → 반복
    
- 성진
    - server.js로 MSW handlers.ts handlersUtils.ts 작성, 인자와 반환값을 확인
    - 단위 테스트 없이 1번 반복유형 선택과 2번 반복 간격 설정을 통합 테스트로 끝내버렸으나,
    - 공통 세션이후 잘못됨을 인지하고, 다시 eventsUtils의 단위 테스트 부터 시작할 예정..
    - 단위 > 통합 > E2E

- 동현    
    - 현재) 전부 다 단위 (1,2,4,5,6)    
    - 생각) 1,2,4,8,9 를 단위로 하고 ⇒ 폼 작성 저장 확인 UI 까지 플로우 를 통합으로 하고 ⇒ e2e로 5,6,10 플로우랑 버그 확인 || e2e 5,6,10 이유: UI랑 상태랑 얽혀있는 복잡한 시나리오라 
    
- 유진
    - 기본과제 요구사항 1, 2, 4, 6번을 단위 테스트로 진행, 3번과 5번은 아이콘 확인을 위해 e2e 테스트로 진행

### 합의된 테스트 전략과 그 이유는 무엇인가요?

> 최종적으로 단위 테스트 > 통합 테스트 > E2E 테스트로 작성하기로 했으며, 비중은 5:3:2 수준으로 측정하였습니다. 
> 현재 일정 관리 서비스는 공통 컴포넌트가 적고, UI가 단순하며, 모든 기능이 한 화면에 배치되어있다는 특징을 가지고 있습니다.
> 의존성 없이 검증 가능한 함수와 hook 단위의 테스트 부터 검증합니다.
> 모킹 데이터를 사용하지만 비즈니스 로직이 검증 가능한 통합 테스트를 진행합니다.
> 이후 실제 시나리오와 비슷한 E2E 테스트로 주요 MVP로직을 검증하여 비용을 줄입니다.

### 추가로 작성된 테스트 코드는 어떤 것들이 있나요?

- eventUtils 단위 테스트
  
  ![unit](https://github.com/user-attachments/assets/9b01ab01-2c92-42e2-9d3e-e98339b3aba9)

- useEventOperations Hook 단위 테스트
  
  ![unit-hooks](https://github.com/user-attachments/assets/6ea59b0f-9877-4072-985e-6f518d057bb8)

- 반복 일정 명세에 따른 통합 테스트
  
  ![integration](https://github.com/user-attachments/assets/07aaec46-5bd6-4881-bb29-4bc9a3464d16)

- 앱의 주요 기능 위주의 E2E 테스트
  
  ![e2e](https://github.com/user-attachments/assets/24aa5d7a-e091-483f-9006-f0fdbb600c06)


---

## 과제 셀프회고

### 기술적 성장
- 추가된 기능에 대한 단위 테스트, 통합 테스트를 구현할 수 있게 되었습니다.
- 이후 사용자 행동에 따른 반복 일정을 등록, 수정, 삭제 하는 E2E 테스트 환경을 세팅하고, 테스트 할 수 있게 되었습니다.

### 코드 품질

- 단위 테스트 
  - `src/__tests__/unit/custom.eventUtils.spec.ts` 
  - `src/__tests__/hooks/custom.useEventOperations.spec.ts`
  - `eventUtils.ts`에 추가로 구현한 `createRepeatEvents`에 대하여 조건문에 `type`별 조건문에 해당하는 결과를 정상적으로 테스트했습니다. 
  - `useEventOperations.ts`에 추가로 구현한 `saveRepeatEvent` 함수에 대한 등록 및 등록된 이벤트에 대한 단일 수정, 단일 삭제를 정상적으로 테스트했습니다.
  - 요구 사항 중 화면과 관계 없는 조건에 따른 이벤트 배열 생성에 대한 테스트를 작성했습니다.
  - 함수와 훅 자체의 동작과 관련된 정보만 주입하여 예측가능한 결과값을 반환받아 테스트하였습니다.

- 통합
  - `src/__mocks__/handlersUtils.ts`  
  - `src/__tests__/custom.integration.spec.tsx`
  - `setupMockHandlerList`함수를 통해 요구사항 명세에 맞는 Mock API 를 통해 값을 고정하였습니다.
  - 1~6번 기본 요구사항에 맞는 비즈니스 로직을 예측 가능한 컴포넌트의 결과값을 가지고 테스트 하였습니다.

- E2E
  - `tests/custom.e2e.spec.ts`
  - `npx create playwright`를 활용하여 `playwright` 환경을 구성하였고, 팀 전략에 따라 앱의 주요 기능 및 반복 일정과 관련된 기능 위주로 테스트하였습니다.
  - `e2e:ui` 환경을 통해 추가 기능에 대한 사용자 행동을 단계적으로 실제 랜더링 된 화면을 기반으로 테스트하였습니다.

### 학습 효과 분석

- 초반에 요구사항을 그대로 사용하여 테스트 명세를 작성하고나니, 만들어진 함수와 조건에 대한 검증 없이 통합 테스트를 작성하였었습니다. 
- 공통 세션과 멘토링 이후에 만들어 둔 함수와 훅에 대한 단위 테스트 부터 다시 테스트 명세를 작성하였고,
- 요구사항 문장 그대로가 아닌, 요구사항을 충족하면서 추가 주요 기능을 검증 할 수 있는 테스트 명세로 변경하였습니다.
- 이후에는, 단위 > 통합 > E2E 팀 전략에 맞게 반복 일정에 대한 추가 기능 테스트를 구현하였습니다.

### 과제 피드백

- 지난 주는 테스트 코드가 무엇인 지 확인하고 친해지는 단계였다면, 이번 주는 일반적인 개발의 흐름 처럼 테스트 코드 구현이 되었던것 같습니다.
- 처음엔 통합을 먼저 작성하다 만들어 준 일일 반복 유틸 함수를 기준으로 각 주, 월, 연 조건에 대한 단위 테스트를 먼저 정의 하고 함수에 입력값과 결과값을 확인하면서 기능을 구현했던 부분이 특히 또 다른 형식의 개발 흐름을 체득한 것 같아 좋았습니다. 

- 저번주에 Hard 도전 하면서 세팅해봤던 부분들이 이번 과제에 도움이 많이 되어 지난주에 비해 막히는 부분이 적었습니다.
- 테스트 명세를 어떻게 작성할까하는 부분에 대한 의문이 있었는데 멘토링 시간에 it으로 먼저 다 나눠두고 만들다가 묶을 수 있는 것들이 보이면 묶는 방식이라고, 일반 개발과 다를 바 없다 하신 부분이 확실히 많이 도움이 되었던 것 같습니다.
- 선택 요구사항 까진 해보지 않았지만, 특화된 기능을 가진 앱에 대하여 개발을 할 때, TDD도 고려해 볼 수 있을 것 같다는 생각이 들었습니다.

## 리뷰 받고 싶은 내용

- e2e 테스트 시에 실제 데이터 수정이 발생하는 것을 확인했고, 상황을 `test.describe.serial`로 묶어서 진행하였습니다.
  1. 반복 일정 생성 후 캘린더와 목록 확인(realEvents.json 수정됨)
  2. 데이터가 그대로 있는 상태에서  다음달로 넘어가 이미 등록된 일정을 수정하고 저장. 해당 이벤트만 반복 일정에서 제외됨.
  3. 다시 현재월로 이동하여 반복 일정을 단일 삭제로 삭제
    + 추가로 등록했던 반복 일정을 하나씩 찾아서 단일 삭제를 반복(realEvents.json 원래 데이터만 남음)

- e2e:ui를 세팅하여 테스트 할땐 워커를 하나씩 만 테스트 하다보니 병렬 실행 시 여러 워커가 실제 파일을 중간에 수정하는 것을 확인하였습니다.
- 이에 serial을 해제하고, 2번 수정 과정과 3번 삭제 과정 이전에도 데이터를 생성하도록 변경하였습니다.
- 하지만, 워커의 동작이 순서가 없다보니, 다른 워커가 수정에 테스트를 추가했더라도, 더 빨리 끝난 워커가 전체 삭제하는 로직을 동작하여 수정할 이벤트가 없어서 실패하는 상황이 발생하는 것을 확인하였습니다.

![image](https://github.com/user-attachments/assets/cddad616-0146-42ff-8dc2-b9b77be9c1dc)

- 이에 따라서, playwright test 실행 시 workers를 1로 제한하고,
- server.js에서 realEvents.json 대신 realEvents-${randomUUID()}.json 을 만들어서 저장소로 사용,
- 워커 종료 시 afterAll에서 생성했던 파일을 삭제하는 방식으로 실행했습니다.
- 다만, 실행 중인 서버에 path를 보낼 방법이 없어 env에 담아 참조하는 불안전한 방식으로 대응했습니다.

<details><summary>tempJson.ts 👈🏻</summary>

```ts
import { randomUUID } from 'crypto';
import fs from 'fs';
import path from 'path';

const __dirname = path.resolve();

export const createTempEventFile = () => {
  const id = randomUUID();
  const filePath = path.resolve(__dirname, `src/__mocks__/response/realEvents-${id}.json`);
  fs.writeFileSync(filePath, JSON.stringify({ events: [] }));
  return { id, filePath };
};

export const deleteTempEventFile = (filePath: string) => {
  if (fs.existsSync(filePath)) fs.unlinkSync(filePath);
};
```
</details>
<details><summary>server.js 👈🏻</summary>

```js
/* ... */
app.use(express.json());

// 독립 환경 테스트 JSON 생성
const getFilePath = () => {
  return (
    process.env.EVENTS_JSON_PATH ||
    path.resolve(__dirname, 'src/__mocks__/response/realEvents.json')
  );
};

const getEvents = async () => {
  const data = await readFile(getFilePath(), 'utf8');
  return JSON.parse(data);
};
/* ... */
```
</details>

![image](https://github.com/user-attachments/assets/6b9f80a0-7501-44f2-b421-e4b97e25be9a)
![image](https://github.com/user-attachments/assets/2c6bec91-9124-46b7-8eb7-0a2fc737194e)

- e2e:ui 에선 의도했던 것처럼 워커가 하나씩 실행하고, 파일을 새로 만들어서 테스트 하고 지우고, 
- serial을 통해 불필요하게 수정 전 이벤트 생성, 삭제 전 이벤트 생성하는 로직을 제거하였습니다.
- e2e는 워커의 속도 차이 때문인 지, 거의 실패, 간헐적 성공 상태를 뱉었는데, 
- 과제 제출 시간이 부족하여 ui에서 천천히 동작하여 성공하는 것으로 일단 e2e 과제를 마무리 하였습니다.

- 사실 그냥 이 때, 수정이나 삭제를 굳이 등록했던 데이터로 확인하지 않고, 수정할 이벤트 따로, 삭제할 이벤트 따로 만들면 구태여 이렇게 까지 안해도 될것 이라는 생각이 들었는데, 통합 테스트의 MSW 처럼 워커간에 환경을 나누고 순서대로 진행하는 사용자 테스트를 만들어 보고 싶어서 추가적으로 세팅을 했었습니다.
- 추가적으로 server.js 대신에 테스트 용으로 filePath를 주입받아서 Express를 반환 해주는 `function createE2EApp(jsonFilePath: string)` 을 만들어서 분리 해보려고 하였으나, vite에서 빌드되면서 /api 에 매핑 된 port와 일치 시키는 작업이 불가능 하다는 것을 깨닫고 해당 방법은 포기하였습니다.
- 마지막으로 page.addInitScript를 이용하면 가상으로 events 배열을 테스트 중에 사용하고 종료할 수 있다는 걸 늦게 확인하여 약간의 아쉬움이 남았습니다. 추후에 e2e까지 제대로 된 독립된 환경 세팅을 복습해보도록 하겠습니다.

---

- 전략까지만 팀 토의 진행하였고, 심화 테스트 코드 작성은 제가 일정이 있어서 개별적으로 먼저 작성했습니다.
